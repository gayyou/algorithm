## 背包问题总结
### 背包物品的简单介绍

​	有若干类物品，每个物品都有价值V、重量W和数量，你现在有一个背包，可以装下C重量的物品，那么怎样进行选择才会得到最优解呢？

#### 1.01背包

- 01背包的特征是这堆物品每种物品只有一项，每件物品要么拿，要么不拿。

- 由动态规划来进行解决的，我们需要得出这种问题的递推式：

  - 第i个物品的最高价值的决定因素为F(i, w) = max{F(i - 1, w), F(i - 1, w - W[i]) + V[i]};w为当前背包内的重量

  也就是第i个物品的最大价值有两种可能：1.是前面i - 1个物品组成w的重量的价值。2.是前i - 1个物品组成的重量为w - W[i]的时候最大值加上第i个物品时候的最大值的情况。两者之间选最大值。

- 很明显，这个递推式是从第一个物品一个一个推导出来的，所以有一定有下标0-i，并且重量也是递推的，所以也有下标从0-w。所以它是一个二维数组，这个数组的行数就是加入第i个物品，列数是总量。

- 所以一般情况下需要一个二维数组来进行存储前i个物品在重量为w时候的最大价值。但是很容易就发现一般情况下只需要最大价值，很多时候都会产生不必要的内存浪费。所以接下来就用1维数组来代替二维数组，实现内存的压缩。

- 1维数组解决。首先我们根据递推式可以观察到，第i个物品在重量为w的时候的最大值都是由i-1个物品来决定的，也就是说，第i行的最大价值是前一行的最大价值所决定的。那么我们只需要记录一行，然后新起来的一行是由前一行通过计算得到的。

- 那么可以得出以下的伪代码：

- ```
  设有n个物品，背包的容量为w，则有以下表达式，
  int[] dp = new int[w + 1];
  
  for (i = 1 -> n) {
    for (j = w -> 1) {
      dp[j] = max{dp[j], dp[j - w[i]] + v[i]}
    }
  }
  
  有很多同学会问?为什么内部循环是从w算起的？而不是从开始算起的？
  这是因为我们的物品只能选一项，然后dp在遍历前是i - 1时候的最大值，如果从正向便利店的时候dp[j - w[i]] + v[i]这条式子会产生一个物品被拿了两次的后果。
  ```

#### 2.完全背包

- 完全背包的特征是每个物品都有无限个，可以随意拿。
- 这样的话，每个物品拿到的个数可能就是0-w/W[i]个数了，如果每个物品都有数量的话，会多一层循环，这样计算量就有n * w * w/W[i]的计算量了，然后存储最大价值的数组起码得三维，这样空间也占有了很多。
- 换个思路想，每个物品是0-w/W[i]的话，如果我们换一种方式，就是将每个物品拆分成多个物品，然后多个物品之间能够通过组合满足完全背包的要求，那么这样的话我们就可以把问题转为01背包了。如果物品有n个，那么可以换成1、2、4、log2n，这样子可以通过组合达到任意个物品（用2的k次方是能够做到的），这样虽然多出来了物品项（如2个物品的就是2V，2W），但是将问题进行了简化。时间复杂度是O(n*Elog(w/W[i]))
- 还有一个更好的解决方法，时间复杂度为O(VN)，它的思想是什么呢？
  - 还记得01背包的时候，为什么内存循环的时候会是从w到1呢？那是因为每件物品只能取一次，如果正向迭代的话，就会产生一个物品拿多次的情况。所以我们可以在内层循环中，进行正向循环，此时dp[j - w[i]]不再是前i - 1个物品的基础上进行计算了，而是前i个物品的最优解上进行计算了，这样符合完全背包问题。

#### 3.多重背包

- 多重背包的话，解题思路是将多重背包问题转为01背包进行求解。

#### 4.混合背包

- 混合背包问题的特征是多个物品中，某个物品可能是01背包模型，也有可能是完全背包模型，也有可能是多重背包问题，这种情况的话，就要根据物品的情况选择对应的方法来进行处理，如果是01背包模型的话，用01背包的方法处理第i行什么的。。。

#### 5.分组物品背包模型

- 分组背包问题，特征是物品分组，但是每个分组里面只能选择一个或者0个来进行挑选。
  - 面对这样的问题，如果将这个分组看做一个整体的话，它就是01背包问题。那么我们可以在01背包里面加一个循环，就是循环分组的内容，得出最优解，然后这个最优解就是这个分组的解。

#### 6.二维费用问题

- 二维费用的话，就是说某件物品有两种耗费资源的值，这两种是互不相干的，但是都有上限。比如说一个物品它有体积和重量，然后背包的话有体积上限以及重量上限。这时候就有两个约束条件，这种问题其实可以用1维的思路来进行处理的。
- 根据数量可以确定是01背包、完全背包、多重背包模型。然后有两个条件进行处理。

