## 思路
- 这道题有两个关键字，数据流and中位数，先说数据流，数据流的话题目的含义是我们并不会知道这个数据流的长度，所以一般情况下是无法通过长度来进行创建容器缓存数据的。要么等这个数据流拿到手后再进行，要么弄一个足够大的容器装着（不实际）
。所以这道题的思路不应该从一些固定长度的数据来讲起，我们需要有一些不定长的数据结构
如链表、树等等，而不是数组。
- 中位数：这个中位数的含义仅仅是拿到中位数就够了，不需要排序。但是如果这个数据流已经排序了，那么就很简单能够拿到中位数。
但是排序的事件复杂度是nlogn，这明显不是最佳答案。前面有一道求出前K个最小的数，它并不需要完全排序，只需要保证左边的数小于右边的数就足够了。
那么我们就明确需要一种数据结构来存储，可以只用一个实例来存储（由中间划分），也可以用两个实例来存储。然后保证这两个实例的大小相差不超过1.

按照这个思路，我们很容易想到
- 链表，链表的话思路和前面的划分思路一致。但是查找速度上是一个难题
- 二叉搜索树：不用想肯定是平衡二叉树，平衡二叉树的特点就是左右高度相差不超过1（但是不保证根节点就在中位数附近）。并且在构建的时候实际上
是对这个数据流进行完全排序了，这样肯定会损耗时间。
- 这时候我们会想起用堆这个数据结构。首先堆它是一棵完全二叉树，不需要进行构建操作。并且堆这个数据结构分为大顶堆和小顶堆。如果我们同时拥有大顶堆和小顶堆，并且这两个堆的size相差不超过1的话，我们是可以拿到中位数的（根据堆顶元素来拿）
